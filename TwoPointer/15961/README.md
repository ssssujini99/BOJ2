## 회전 초밥 🍣

> **💡핵심**   
> 먹을 수 있는 초밥의 가짓수의 최댓값 구하기

아주 단순히 생각해보면 N번 입력받은 초밥에서 매 i번째마다 연속해서 먹는 k번을 계산해주면 된다.   
-> 하지만 이렇게 계산했을 경우 시간복잡도는 O(N*k) 가 된다   
* N <= 3,000,000 이고 k <= 3,000 이므로 시간 터질 수 있음
* 따라서 O(N)안에 이를 해결할 수 있어야 한다. -> 그래서 그냥 바로 슬라이딩 윈도우가 생각났다


### ✔️ 복기

* 원형 큐 형태 이므로, 입력받은 값에 처음원소부터 k-1번째 만큼 더 넣어주어야 원 형태 유지 가능
* 몰랐는데, map의 value가 0이어도 size()에 같이 계산됨 -> 아예 um.erase(key값); 으로 제거해줘야함
* 투포인터 문제집에 있었는데, 풀고보니 슬라이딩 윈도우였다..


### ✔️ unordered_map vs. ordered_map

* unordered_map의 key들은 정렬되어 있지 X
* map의 key들은 정렬되어 O   
   

* map
  * 자동으로 정렬되는 컨테이너
  * 키 값 쌍들로 정장되며 이진 탐색 트리 기반
  * 탐색 시간이 O(log n )
  * 삽입과 제거가 빈번하면 느려집니다.

* unordered_map
  * 자동으로 정렬되지 않는 컨테이너
  * map의 요소 삽입, 제거 빈번할 경우 느려짐을 해결하기 위해 나옴
  * 키 값 쌍들로 저장
  * 해쉬 테이블 기반
  * 탐색 시간이 O(1)로 충돌이 없을 경우 빠름
    * 최악의 경우 O(n)으로 늘어날 수 있음
  * 버킷 때문에 메모리 사용량이 증가