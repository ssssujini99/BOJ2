## 사고의 흐름 과정 정리

* ✨ **3x3 행렬에서 가장 왼쪽 윗칸을 기준을 잡았다 -> (0, 0) 위치에 해당하는 칸** ✨

* 처음엔 단순무식한 시간복잡도 O(N*K) 의 방법으로 풀었다가
  * 단순히 보석을 가격으로 내림차순 정렬한 후(우선순위 큐), 가방 무게 오름차순으로 돌면서 해당 큐에서 보석을 꺼내는 방법
  * sol2.cpp
  * 7% 에서 계속 시간초과를 났다
  * 이후에서야 O(N*K)의 시간복잡도,  (1 ≤ N, K ≤ 300,000) 를 깨닫고 다른 접근방법을 생각해보았다.


* 질문검색 게시판에서 multiset을 이용하라는 힌트를 얻고, 이를 다시 풀게 되었다 -> sol1.cpp
  * 핵심은 다음과 같다
    * "**보석을 가격 내림차순으로 정렬 후, 해당 보석을 넣을 수 있는 가방이 있는지 찾기**"
    * 즉 검색을 ~~보석에서 하는 것이 아닌~~, 보석을 넣을 수 있는 **가방을 검색**하는 것이다.
    * ✔️ 비싼 보석일수록 우선도가 높으며, 이를 넣을 수 있는 가방이 존재하는지 찾기
      * 시간복잡도: O(N * log(K))


### 가방검색에서 시간복잡도가 log(K)인 이유❓

> set(multiset)이 내부적으로 **balanced한 BST 구조**이기 때문에   
> 검색 및 삽입, 삭제에서 O(log K)의 시간복잡도를 갖게 됩니다