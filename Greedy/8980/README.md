## 8980 택배 📦


뭔가 이전에 풀었던 강의실 배정이나 그런 문제들과 비슷하다고 느꼈다.   
" 시작하는 시간 - 끝나는 시간 " 이거나 " 보내느 마을 - 끝나는 마을 " 이 것도 비슷했다고 느꼈다.   

먼저 입력받은 정보부터 정렬이 필요하다.   
받는 마을이 빠른거 기준으로 1차 정렬을 수행 후,   
만약 받는 마을이 같다면 보내는 마을이 늦는 것을 기준으로 (즉 간격이 짧은거 기준) 으로 2차 정렬을 수행하였다.   

### 정렬 기준
* 1차 기준 - 빨리 끝나는 거 기준
* 2차 기준 - 끝나는 시간이 같다면 늦게 시작 먼저 == 즉 간격이 짧은거 기준


그리고 트럭의 용량을 초과하여 짐을 실을 수 없기 때문에,  
각 마을 이동 시 각 마을에서 담을 수 있는 박스 수를 기록해두어야 한다  
-> 배열 ``` int mauel[2001] = {0, }; ``` 이용   

핵심 로직은 다음과 같다.   

```cpp
    for(int i=0; i<v.size(); i++) {

        int flag = 1;
        int w = ( C >= v[i].count ? v[i].count : C ); // 최대 이걸로 시작

        for(int j=v[i].send; j<v[i].get; j++) {
            if(mauel[j] == C) { // 못 실음
                flag = 0;
                break;
            }
            else { // 만약 담을 수 있는 무게가 작아지면 작아진대로 갱신해주기
                int maxC = C - mauel[j]; // 해당 j 마을에서 담을 수 있는 최대 무게
                w = ( maxC >= w ? w : maxC );
            }
        }

        // 넣을 수 있는 무게 값 넣어주기
        if(flag != 0) {
            ans += w;

            for(int j = v[i].send; j<v[i].get; j++) {
                mauel[j] += w;
            }
        }
    }
```

핵심은 그 간격에서 실을 수 있는 최대 무게를 구하는 것이다.
첫 시작을 ```int w = ( C >= v[i].count ? v[i].count : C );``` 로 세팅해서 시작해   

각 간격 구간을 하나씩 확인하면서, 이미 담아놓은 무게가 있을 수 있으므로   
담을 수 있는 무게로 갱신시켜 나가면 된다.   

```cpp
int maxC = C - mauel[j]; // 해당 j 마을에서 담을 수 있는 최대 무게
w = ( maxC >= w ? w : maxC );
```

// 담을 수 있는 최대 무게 이하라면 -> 그대로 w
// 담을 수 있는 최대 무게보다 작다면 -> 최대 무게 담기


그리고 최종 w 값을 기준으로 -> 이제 이 무게를 담을 거니까   
그 간격에 있는 마을 배열을 갱신시켜 주는것도 잊지 않아야 한다!