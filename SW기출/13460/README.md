## 복기

처음에 8% 에서 틀렸습니다 가 떴고,
test case 중에서 

```
5 10
##########
#.#......#
##.......#
#OR..B.#.#
##########

정답: 7
출력: -1
```

이 반례를 통해 놓친 부분을 잡아낼 수 있었다.


* 틀린 지점
  * 조건을 걸때 두 구슬이 동시에 있을 수 없으므로
  * 항상 어떤 구슬이 해당 좌표에 위치하면 다른 구슬이 해당 위치에 위치할 수 없도록 했었다
  * 하지만,
  * 해당 부분에서 ```move_left()``` 를 했을 경우 이 전의 틀린 코드로는 R는 빈칸지점에 도달.
  * but 그 다음 B가 왼쪽으로 이동할 때 R가 O에 위치하므로 B가 O에 도달하지 못하는 상황이 발생

* 해결
  * 해당 map은 항상 고정시킴 (구슬 자리도 빈자리임) / 구슬만 이동시킴
  * 구슬이 O에 위치하면 아예 해당 구슬의 x, y 좌표를 범위 밖의 (-1, -1)로 지정해줌
    * 따라서, 어떤 구슬이 먼저 구멍에 빠져도 다른 구슬도 동시에 빠지는 경우를 잡아낼 수 있었음


* 요약
  * 두 구슬이 같은 직선 상에 위치할 때에, 한 구슬이 구멍에 빠지고 다른 구슬도 빠지게 되는 경우를 잡지 못했음
  * 이 예시는 실패의 예시다 (빨간색 구슬만 통과해야하므로)
  * 근데 이를 계속 성공 케이스로 계산해서 오답을 내고 있었음
    * 어떤 구슬이 먼저 구멍을 통과한 경우, 그 구슬의 위치를 구멍의 위치로 잡으면 안됨
      * 그러면 다른 구슬이 구멍에 들어올 수 없으므로!!
    * 따라서 먼저 구멍을 통과한 구슬의 좌표를 아예 map 밖으로 잡아서, 나머지 구슬도 구멍에 들어갈 수 있게 해줌


* 느낀점
  * 어렵지 않은 줄 알고 덤볐다가 3시간 넘게 하.. 거의 4시간? 잡아먹은 문제였다
  * 2048 문제보다 쉬운 줄 알았는데... 얘가 좀 더 조건이 까다로운 것 같다
  * 항상 구현 전에 먼저 여러 시뮬레이션 돌려보고 조건 써가며 꼼꼼히 푸는 습관을 더 가져야겠다
  * 일찍 푸는 것이 중요한 것이 아니다 !!! 문제 완벽히 이해하고 조건 꼼꼼히 따질 것