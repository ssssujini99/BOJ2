## 최단경로 알고리즘 1 - 다익스트라 알고리즘

* 각 edge 마다 **0 이상의 가중치**를 갖는 Directed (방향O), Weighted graph (가중치O) 가 주어진다.
* 가중치는 <i, j> edge를 사용하여 i에서 j로 가는데 들어가는 cost로 해석
* 두 vertex 사이의 최단경로는 cost의 합(들)이 최소가 되는 경로
* 하나의 vertex에서 출발하여, 모든 vertex로 가는 최단경로를 구하는 알고리즘
* **그리디 알고리즘**의 하나
* 다이나믹 프로그래밍을 활용한 최단 경로 탐색 알고리즘   
  ✔ 최단 거리는 여러 개의 최단 거리로 이루어져있기 때문에 작은 문제가 큰 문제의 부분 집합에 속해있다고 볼 수 있음 -> DP   
  ✔ 하나의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용함 -> DP


### ⭐️ 나름 중요한 부분
> #### 알고리즘 목적: (다이나믹 프로그래밍을 활용한) 최단 경로 탐색 알고리즘
> 특정한 하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 알려준다

* 다익스트라 알고리즘의 가중치는 **0 이상!!** (~~음의 간선은 포함X~~)
* -> 그래서 현실세계에서 사용하기 매우 적합한 알고리즘 (현실세계에서 음의 가중치는 거의 없기 때문에)
* 다익스트라 알고리즘은 그리디 알고리즘 중 하나


### ⭐️ 코드 분석

```cpp
    for(int i=1; i<=V; i++){
        d[i] = 987654321;
    }

    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<> > pq; // {거리, 노드}
    d[S] = 0; // 시작점까지의 거리 = 0
    pq.push({0, S});

    while(!pq.empty()){
        int dis = pq.top().first; int node = pq.top().second;
        pq.pop();

        if(d[node] < dis) continue; // 갱신할 필요가 없는 경우 -> continue

        for(int i=0; i<vec[node].size(); i++){
            if(dis + vec[node][i].second < d[vec[node][i].first]){
                d[vec[node][i].first] = dis + vec[node][i].second;
                pq.push({d[vec[node][i].first], vec[node][i].first});
            }
        }
    }
```



* 문제 풀 때에 계속 틀렸던 부분 원인 분석 및 사고 과정 정리   

https://www.acmicpc.net/board/view/87434   
해당 자료의 예시? 를 보고 문제점을 파악할 수 있었다

그 전까지는 계속 노드 방문 체크 따로 / 거리 갱신 따로 생각을 해 주어서 시간초과나 계속 몇퍼센트에서 틀렸었다   
단순히 체크 배열로 **방문을 했냐 / 안했냐** 의 여부만 따져서는 안 되고,   
> **❗️거리를 갱신을 할 수 있는가 아닌가❗️ 로 따져줘야 한다.**   

그래서, ~~따로 체크 방문 여부를 boolean으로 확인할 필요 없이~~  
거리 배열 하나로 (문제 풀이에서는 배열 d)   
해당 노드에서의 거리 갱신 여부를 판별하면 된다.

그리고 a -> b 로 이동할 때에 거리가 2, 3, 4 , .. 등 많을 수도 있다는 해당 링크의 예시로    
이 과정을 도출해 낼 수 있었다.   
즉 그니까 여기서 거리가 3, 4는 다 필요가 없는 것이다 (거리 2가 최소이므로 이것만 필요)   
그래서 2일때에만 갱신 과정을 거치면 되고,   
3, 4인 경우는 모두 continue 시켜주면 된다.   