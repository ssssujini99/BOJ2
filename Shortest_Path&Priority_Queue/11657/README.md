## 최단경로 알고리즘 2 - 벨만포드 알고리즘

> 최단 경로 문제 정리
>>  1. 모든 간선이 양수인 경우  -> 다익스트라 O
> 
>>  2. 음수 간선이 있는 경우 -> 다익스트라 X   
>> * 음수 간선 순환 O  -> 답 도출 X
>> * 음수 간선 순환 X  -> 벨만포드 O

* 각 edge 마다 가중치(음수도 가능)를 갖는 Directed (방향O), Weighted graph (가중치O) 가 주어진다.
* 가중치는 <i, j> edge를 사용하여 i에서 j로 가는데 들어가는 cost로 해석
* 두 vertex 사이의 최단경로는 cost의 합(들)이 최소가 되는 경로
* 하나의 vertex에서 출발하여, 모든 vertex로 가는 최단경로를 구하는 알고리즘
* **모든 경우를 다 탐색**해 가면서 최소비용을 찾게 된다
* ~~그리디 하지 않고~~, **모든 경우의 수를 탐색**하는 동작 원리   
  (다익스트라 - 지금 당장 눈앞에 보이는, 연결되어 있는 정점 중에서 최소비용으로 연결된 정점을 선택)


### ⭐️ 나름 중요한 부분
> #### 알고리즘 목적: 최단 경로 탐색 알고리즘
> 특정한 하나의 정점에서 다른 모든 정점으로 가는 최단 경로를 알려준다   
> (목적은 다익스트라랑 동일)

* 벨만 포드 최단 경로 알고리즘은 **음의 간선**이 포함된 상황에서도 쓸 수 O
* 벨만 포드의 기본 시간 복잡도는 **O(VE) == O((정점 수 - 1)\*(간선 수))** 로 다익스트라에 비해 느림
* 벨만 포드는 매 사이클마다 모든 간선을 다 탐색(모든 경우를 다 탐색) 한다는 점에서 ~~그리디하지 않음~~


### ⭐️ 벨만 포드 알고리즘 작동 과정
 
1. 출발 노드를 설정   
2. 최단 거리 테이블을 초기화   
3. 다음의 과정을 (N-1)번 반복 (정점 수 - 1 번 )
   1. 전체 간선을 하나씩 확인   
   2. 각 간선을 거쳐 다른 노드로 가는 비용을 계산해서 최단 거리 테이블 갱신   


> ### ✅ 벨만 포드 알고리즘 시간복잡도 : O((V-1)*E) == O((정점 수 - 1)*(전체 간선 수))



### ⭐️ 코드 분석

```cpp
    for(int i=1; i<=N; i++) d[i] = INF; // 거리 초기화

    d[1] = 0; // 1번 도시에서 출발
    for(int i=0; i<N-1; i++){ // (정점 - 1) 번 == (노드 수 - 1) 번 만큼 반복
        for(int j=0; j<vec.size(); j++){ // 한 사이클마다 모든 간선 확인해주기 -- > 시간복잡도: O((N-1) * V) == O((정점 수-1) * 간선 수)
            if(d[vec[j].A] != INF && d[vec[j].A] + vec[j].C < d[vec[j].B]) d[vec[j].B] = d[vec[j].A] + vec[j].C;
        } // 추가: 1번 -> A 까지의 거리가 무한대이면 안됨 !! (주의)
    } // 간선을 잇는 출발정점이 '한번이라도 계산이 된 정점이라면' 해당 간선이 잇는 정점의 거리를 비교해서 업데이트한다
```



* 문제 풀 때에 틀렸던 부분 원인 분석 및 사고 과정 정리   

몇 개의 테스트케이스 예시를 대입하면서 틀렸었던 부분을 알 수 있었다.   

각 사이클에서 모든 간선을 체크해줄 때에, **간선을 잇는 출발정점이 ~~INF 값이 아닌~~ 경우에만 갱신**을 해 주어야 하는데   
이 부분을 빼먹어서 자꾸 60%에서 틀렸다고 나왔다.

거리 갱신을 해 줄 때에, 전제조건으로
> **❗️간선을 잇는 출발정점이 INF 값이 아닌지 == (간선을 잇는 출발정점이) 한번이라도 계산이 된 정점인지❗**️ 먼저 따져줘야 한다.   

이 부분만 유의해주면 될 것 같다.